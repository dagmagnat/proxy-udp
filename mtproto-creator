#!/usr/bin/env bash
set -euo pipefail

CONF="/etc/mtproto_manager.conf"
CONTAINER_NAME="mtproto-proxy"
IMAGE="telegrammessenger/proxy:latest"

# --- helpers ---
require_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    echo "Запустите от root: sudo $0" >&2
    exit 1
  fi
}

cmd_exists() { command -v "$1" >/dev/null 2>&1; }

valid_port() {
  local p="${1:-}"
  [[ "$p" =~ ^[0-9]+$ ]] || return 1
  (( p >= 1 && p <= 65535 )) || return 1
  return 0
}

port_allowed() {
  local p="$1"
  # запрещаем 80/443 и низкие порты (можно оставить, но безопаснее)
  [[ "$p" != "80" && "$p" != "443" ]] || return 1
  return 0
}

port_free() {
  local p="$1"
  # проверка занятости порта (tcp listen)
  if cmd_exists ss; then
    ! ss -lnt "( sport = :$p )" 2>/dev/null | grep -q ":$p"
  elif cmd_exists netstat; then
    ! netstat -lnt 2>/dev/null | awk '{print $4}' | grep -q ":$p$"
  else
    # fallback: best-effort
    return 0
  fi
}

rand_hex() {
  # 16 bytes => 32 hex
  if cmd_exists openssl; then
    openssl rand -hex 16
  else
    # fallback /dev/urandom
    head -c 16 /dev/urandom | od -An -tx1 | tr -d ' \n'
  fi
}

choose_port() {
  echo
  echo "Выбор порта для MTProto-proxy (TCP)."
  echo "80 и 443 запрещены."
  echo "1) Случайный свободный порт (рекомендуется)"
  echo "2) Указать свой порт"
  echo "0) Назад"
  echo
  read -r -p "Ваш выбор: " sel

  case "$sel" in
    1)
      local p tries=0
      while true; do
        # диапазон 20000-65000 чтобы реже конфликтовать
        p=$((20000 + (RANDOM % 45000)))
        tries=$((tries+1))
        if valid_port "$p" && port_allowed "$p" && port_free "$p"; then
          echo "$p"
          return 0
        fi
        ((tries >= 200)) && { echo "Не смог подобрать свободный порт." >&2; return 1; }
      done
      ;;
    2)
      local p
      read -r -p "Введите порт (1-65535, кроме 80/443): " p
      valid_port "$p" || { echo "Неверный порт." >&2; return 1; }
      port_allowed "$p" || { echo "Порт 80/443 запрещён." >&2; return 1; }
      port_free "$p" || { echo "Порт занят." >&2; return 1; }
      echo "$p"
      return 0
      ;;
    0) echo "back"; return 0 ;;
    *) echo "Неверный выбор." >&2; return 1 ;;
  esac
}

install_docker_apt() {
  apt-get update -y
  apt-get install -y docker.io
  systemctl enable --now docker
}

ensure_docker() {
  if cmd_exists docker; then
    return 0
  fi

  echo "Docker не найден. Пытаюсь установить..."

  if cmd_exists apt-get; then
    install_docker_apt
  else
    echo "Автоустановка поддерживается только для Debian/Ubuntu (apt). Установите Docker вручную." >&2
    exit 1
  fi

  cmd_exists docker || { echo "Docker не установился." >&2; exit 1; }
}

save_conf() {
  local port="$1" secret="$2" tag="$3"
  cat > "$CONF" <<EOF
PORT=$port
SECRET=$secret
TAG=$tag
CONTAINER=$CONTAINER_NAME
IMAGE=$IMAGE
EOF
  chmod 600 "$CONF"
}

load_conf() {
  if [[ -f "$CONF" ]]; then
    # shellcheck disable=SC1090
    source "$CONF"
  else
    PORT=""
    SECRET=""
    TAG=""
    CONTAINER="$CONTAINER_NAME"
    IMAGE="$IMAGE"
  fi
}

open_firewall_iptables() {
  local port="$1"
  # best-effort open input tcp port
  if cmd_exists iptables; then
    iptables -C INPUT -p tcp --dport "$port" -j ACCEPT 2>/dev/null || \
      iptables -I INPUT -p tcp --dport "$port" -j ACCEPT
  fi
}

get_public_ip() {
  # best-effort: curl to multiple endpoints
  local ip=""
  if cmd_exists curl; then
    ip="$(curl -fsS --max-time 3 https://api.ipify.org 2>/dev/null || true)"
    [[ -z "$ip" ]] && ip="$(curl -fsS --max-time 3 https://ifconfig.me 2>/dev/null || true)"
  elif cmd_exists wget; then
    ip="$(wget -qO- --timeout=3 https://api.ipify.org 2>/dev/null || true)"
    [[ -z "$ip" ]] && ip="$(wget -qO- --timeout=3 https://ifconfig.me 2>/dev/null || true)"
  fi
  echo "$ip"
}

print_link() {
  load_conf
  if [[ -z "${PORT:-}" || -z "${SECRET:-}" ]]; then
    echo "Прокси не настроен (нет конфигурации)." >&2
    return 1
  fi

  local ip
  ip="$(get_public_ip)"
  if [[ -z "$ip" ]]; then
    echo "Не удалось определить публичный IP автоматически."
    echo "Ссылка будет без IP. Вставьте свой IP вручную:"
    echo "tg://proxy?server=YOUR_IP&port=${PORT}&secret=dd${SECRET}"
    return 0
  fi

  echo
  echo "Готово. Данные MTProto:"
  echo "Server: $ip"
  echo "Port  : $PORT"
  echo "Secret: dd$SECRET"
  [[ -n "${TAG:-}" ]] && echo "Tag   : $TAG"
  echo
  echo "Ссылка для Telegram:"
  echo "tg://proxy?server=${ip}&port=${PORT}&secret=dd${SECRET}"
  echo
}

start_proxy() {
  ensure_docker
  load_conf

  local port secret tag

  if [[ -z "${PORT:-}" || -z "${SECRET:-}" ]]; then
    port="$(choose_port)" || return 1
    [[ "$port" == "back" ]] && return 0

    secret="$(rand_hex)"
    tag=""   # можно задать позже, если нужно
    save_conf "$port" "$secret" "$tag"
    load_conf
  fi

  # если контейнер уже есть — удалим (чтобы пересоздать с параметрами)
  if docker ps -a --format '{{.Names}}' | grep -qx "$CONTAINER_NAME"; then
    docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
  fi

  echo "Запускаю MTProto proxy в Docker..."
  docker pull "$IMAGE" >/dev/null

  # контейнер слушает 443 внутри, наружу мапим выбранный PORT
  # SECRET передаём без dd, dd нужно только в ссылке для клиента
  if [[ -n "${TAG:-}" ]]; then
    docker run -d \
      --name "$CONTAINER_NAME" \
      --restart unless-stopped \
      -p "${PORT}:443" \
      -e "SECRET=${SECRET}" \
      -e "TAG=${TAG}" \
      "$IMAGE" >/dev/null
  else
    docker run -d \
      --name "$CONTAINER_NAME" \
      --restart unless-stopped \
      -p "${PORT}:443" \
      -e "SECRET=${SECRET}" \
      "$IMAGE" >/dev/null
  fi

  open_firewall_iptables "$PORT"

  echo "MTProto proxy запущен."
  print_link
}

stop_proxy() {
  ensure_docker
  if docker ps --format '{{.Names}}' | grep -qx "$CONTAINER_NAME"; then
    docker stop "$CONTAINER_NAME" >/dev/null
    echo "Остановлено."
  else
    echo "Контейнер не запущен."
  fi
}

status_proxy() {
  ensure_docker
  load_conf
  echo
  echo "Статус Docker контейнера:"
  docker ps -a --filter "name=^/${CONTAINER_NAME}$" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
  echo
  if [[ -f "$CONF" ]]; then
    echo "Конфиг: $CONF"
    echo "PORT=${PORT:-}"
    echo "SECRET=dd${SECRET:-}"
    [[ -n "${TAG:-}" ]] && echo "TAG=${TAG}"
  else
    echo "Конфиг не найден: $CONF"
  fi
  echo
}

set_tag() {
  load_conf
  [[ -f "$CONF" ]] || { echo "Сначала создайте прокси (Start/Create)." >&2; return 1; }
  read -r -p "Введите TAG (пусто чтобы очистить): " newtag
  save_conf "${PORT}" "${SECRET}" "$newtag"
  echo "TAG обновлён. Чтобы применить — перезапустите (Restart)."
}

regen_secret() {
  load_conf
  [[ -f "$CONF" ]] || { echo "Сначала создайте прокси (Start/Create)." >&2; return 1; }
  local newsecret; newsecret="$(rand_hex)"
  save_conf "${PORT}" "$newsecret" "${TAG:-}"
  echo "SECRET обновлён. Чтобы применить — перезапустите (Restart)."
  print_link
}

change_port() {
  load_conf
  [[ -f "$CONF" ]] || { echo "Сначала создайте прокси (Start/Create)." >&2; return 1; }
  local newport
  newport="$(choose_port)" || return 1
  [[ "$newport" == "back" ]] && return 0
  save_conf "$newport" "${SECRET}" "${TAG:-}"
  echo "PORT обновлён. Чтобы применить — перезапустите (Restart)."
}

restart_proxy() {
  stop_proxy || true
  start_proxy
}

uninstall_proxy() {
  ensure_docker
  docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
  rm -f "$CONF"
  echo "Удалено: контейнер и конфиг."
}

main_menu() {
  require_root
  while true; do
    echo
    echo "========== MTProto Proxy Manager =========="
    echo "1) Start/Create MTProto proxy"
    echo "2) Stop"
    echo "3) Restart"
    echo "4) Status"
    echo "5) Show Telegram link"
    echo "6) Change port (no 80/443)"
    echo "7) Regenerate secret"
    echo "8) Set/clear TAG"
    echo "9) Uninstall (remove container + config)"
    echo "0) Exit"
    echo "==========================================="
    read -r -p "Ваш выбор: " c

    case "$c" in
      1) start_proxy ;;
      2) stop_proxy ;;
      3) restart_proxy ;;
      4) status_proxy ;;
      5) print_link ;;
      6) change_port ;;
      7) regen_secret ;;
      8) set_tag ;;
      9) uninstall_proxy ;;
      0) exit 0 ;;
      *) echo "Неверный выбор." ;;
    esac
  done
}

main_menu
